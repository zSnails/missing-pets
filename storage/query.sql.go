// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package storage

import (
	"context"
)

const createMissingPet = `-- name: CreateMissingPet :one
INSERT INTO
missing_pets (name, type, last_seen, size, color, owner_id)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, name, type, last_seen, size, color
`

type CreateMissingPetParams struct {
	Name     string `json:"name"`
	Type     string `json:"type"`
	LastSeen string `json:"lastSeen"`
	Size     string `json:"size"`
	Color    string `json:"color"`
	OwnerID  int64  `json:"ownerId"`
}

type CreateMissingPetRow struct {
	ID       int64  `json:"id"`
	Name     string `json:"name"`
	Type     string `json:"type"`
	LastSeen string `json:"lastSeen"`
	Size     string `json:"size"`
	Color    string `json:"color"`
}

func (q *Queries) CreateMissingPet(ctx context.Context, arg CreateMissingPetParams) (CreateMissingPetRow, error) {
	row := q.db.QueryRowContext(ctx, createMissingPet,
		arg.Name,
		arg.Type,
		arg.LastSeen,
		arg.Size,
		arg.Color,
		arg.OwnerID,
	)
	var i CreateMissingPetRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.LastSeen,
		&i.Size,
		&i.Color,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO
pet_owners (name, phone, email, address, hash)
VALUES (?, ?, ?, ?, ?)
RETURNING id, name, phone, email, address
`

type CreateUserParams struct {
	Name    string `json:"name"`
	Phone   string `json:"phone"`
	Email   string `json:"email"`
	Address string `json:"address"`
	Hash    []byte `json:"hash"`
}

type CreateUserRow struct {
	ID      int64  `json:"id"`
	Name    string `json:"name"`
	Phone   string `json:"phone"`
	Email   string `json:"email"`
	Address string `json:"address"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Name,
		arg.Phone,
		arg.Email,
		arg.Address,
		arg.Hash,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Address,
	)
	return i, err
}

const doesUserOwnThePet = `-- name: DoesUserOwnThePet :one
SELECT 1 FROM missing_pets WHERE id = ? AND owner_id = ?
`

type DoesUserOwnThePetParams struct {
	ID      int64 `json:"id"`
	OwnerID int64 `json:"ownerId"`
}

func (q *Queries) DoesUserOwnThePet(ctx context.Context, arg DoesUserOwnThePetParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, doesUserOwnThePet, arg.ID, arg.OwnerID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const findMissingPetsByName = `-- name: FindMissingPetsByName :many
SELECT id, name, type, last_seen, size, color FROM
missing_pets
WHERE remove_special_characters(name)
LIKE remove_special_characters(CAST(?1 AS TEXT))
`

type FindMissingPetsByNameRow struct {
	ID       int64  `json:"id"`
	Name     string `json:"name"`
	Type     string `json:"type"`
	LastSeen string `json:"lastSeen"`
	Size     string `json:"size"`
	Color    string `json:"color"`
}

func (q *Queries) FindMissingPetsByName(ctx context.Context, name string) ([]FindMissingPetsByNameRow, error) {
	rows, err := q.db.QueryContext(ctx, findMissingPetsByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindMissingPetsByNameRow{}
	for rows.Next() {
		var i FindMissingPetsByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.LastSeen,
			&i.Size,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, name, phone, email, address, hash FROM pet_owners WHERE email = ?
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (PetOwner, error) {
	row := q.db.QueryRowContext(ctx, findUserByEmail, email)
	var i PetOwner
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Address,
		&i.Hash,
	)
	return i, err
}

const findUserById = `-- name: FindUserById :one
SELECT id, name, phone, email, address FROM pet_owners WHERE id = ?
`

type FindUserByIdRow struct {
	ID      int64  `json:"id"`
	Name    string `json:"name"`
	Phone   string `json:"phone"`
	Email   string `json:"email"`
	Address string `json:"address"`
}

func (q *Queries) FindUserById(ctx context.Context, id int64) (FindUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, findUserById, id)
	var i FindUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Address,
	)
	return i, err
}

const getAllPetsNameFilter = `-- name: GetAllPetsNameFilter :many
SELECT missing_pets.id, missing_pets.name, missing_pets.type, missing_pets.last_seen, missing_pets.size, missing_pets.color, pet_owners.id as owner_id,
(SELECT api_hash FROM missing_pet_photos WHERE pet_id = missing_pets.id LIMIT 1)
FROM missing_pets 
JOIN pet_owners ON missing_pets.owner_id = pet_owners.id
WHERE (missing_pets.name LIKE CAST(?1 AS TEXT))
LIMIT ?3 OFFSET ?2
`

type GetAllPetsNameFilterParams struct {
	Name   string `json:"name"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

type GetAllPetsNameFilterRow struct {
	ID       int64  `json:"id"`
	Name     string `json:"name"`
	Type     string `json:"type"`
	LastSeen string `json:"lastSeen"`
	Size     string `json:"size"`
	Color    string `json:"color"`
	OwnerID  int64  `json:"ownerId"`
	ApiHash  string `json:"apiHash"`
}

func (q *Queries) GetAllPetsNameFilter(ctx context.Context, arg GetAllPetsNameFilterParams) ([]GetAllPetsNameFilterRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPetsNameFilter, arg.Name, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllPetsNameFilterRow{}
	for rows.Next() {
		var i GetAllPetsNameFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.LastSeen,
			&i.Size,
			&i.Color,
			&i.OwnerID,
			&i.ApiHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContactInfo = `-- name: GetContactInfo :one
SELECT name, phone FROM pet_owners WHERE id = ?
`

type GetContactInfoRow struct {
	Name  string `json:"name"`
	Phone string `json:"phone"`
}

func (q *Queries) GetContactInfo(ctx context.Context, id int64) (GetContactInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getContactInfo, id)
	var i GetContactInfoRow
	err := row.Scan(&i.Name, &i.Phone)
	return i, err
}

const getPetByID = `-- name: GetPetByID :one
SELECT id, name, type, last_seen, size, color, owner_id, (SELECT api_hash FROM missing_pet_photos WHERE pet_id = missing_pets.id LIMIT 1) FROM missing_pets WHERE missing_pets.id = ?
`

type GetPetByIDRow struct {
	ID       int64  `json:"id"`
	Name     string `json:"name"`
	Type     string `json:"type"`
	LastSeen string `json:"lastSeen"`
	Size     string `json:"size"`
	Color    string `json:"color"`
	OwnerID  int64  `json:"ownerId"`
	ApiHash  string `json:"apiHash"`
}

func (q *Queries) GetPetByID(ctx context.Context, id int64) (GetPetByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPetByID, id)
	var i GetPetByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.LastSeen,
		&i.Size,
		&i.Color,
		&i.OwnerID,
		&i.ApiHash,
	)
	return i, err
}

const getUserPets = `-- name: GetUserPets :many
SELECT id, name, type, last_seen, size, color FROM missing_pets WHERE owner_id = ?
`

type GetUserPetsRow struct {
	ID       int64  `json:"id"`
	Name     string `json:"name"`
	Type     string `json:"type"`
	LastSeen string `json:"lastSeen"`
	Size     string `json:"size"`
	Color    string `json:"color"`
}

func (q *Queries) GetUserPets(ctx context.Context, ownerID int64) ([]GetUserPetsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserPets, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPetsRow{}
	for rows.Next() {
		var i GetUserPetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.LastSeen,
			&i.Size,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserPet = `-- name: RemoveUserPet :exec
DELETE FROM missing_pets WHERE id = ? AND owner_id = ?
`

type RemoveUserPetParams struct {
	ID      int64 `json:"id"`
	OwnerID int64 `json:"ownerId"`
}

func (q *Queries) RemoveUserPet(ctx context.Context, arg RemoveUserPetParams) error {
	_, err := q.db.ExecContext(ctx, removeUserPet, arg.ID, arg.OwnerID)
	return err
}

const retrieveImage = `-- name: RetrieveImage :one
SELECT id, pet_id, image_data FROM missing_pet_photos WHERE api_hash = ?
`

type RetrieveImageRow struct {
	ID        int64  `json:"id"`
	PetID     int64  `json:"petId"`
	ImageData []byte `json:"imageData"`
}

func (q *Queries) RetrieveImage(ctx context.Context, apiHash string) (RetrieveImageRow, error) {
	row := q.db.QueryRowContext(ctx, retrieveImage, apiHash)
	var i RetrieveImageRow
	err := row.Scan(&i.ID, &i.PetID, &i.ImageData)
	return i, err
}

const uploadPhoto = `-- name: UploadPhoto :one
INSERT INTO
missing_pet_photos (pet_id, image_data, api_hash)
VALUES (?, ?, ?)
RETURNING id, api_hash
`

type UploadPhotoParams struct {
	PetID     int64  `json:"petId"`
	ImageData []byte `json:"imageData"`
	ApiHash   string `json:"apiHash"`
}

type UploadPhotoRow struct {
	ID      int64  `json:"id"`
	ApiHash string `json:"apiHash"`
}

func (q *Queries) UploadPhoto(ctx context.Context, arg UploadPhotoParams) (UploadPhotoRow, error) {
	row := q.db.QueryRowContext(ctx, uploadPhoto, arg.PetID, arg.ImageData, arg.ApiHash)
	var i UploadPhotoRow
	err := row.Scan(&i.ID, &i.ApiHash)
	return i, err
}
