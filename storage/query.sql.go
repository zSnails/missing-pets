// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package storage

import (
	"context"
)

const createMissingPet = `-- name: CreateMissingPet :one
INSERT INTO
missing_pets (name, type, last_seen, owner_id)
VALUES (?, ?, ?, ?)
RETURNING id, name, type, last_seen
`

type CreateMissingPetParams struct {
	Name     string `json:"name"`
	Type     string `json:"type"`
	LastSeen string `json:"lastSeen"`
	OwnerID  int64  `json:"ownerId"`
}

type CreateMissingPetRow struct {
	ID       int64  `json:"id"`
	Name     string `json:"name"`
	Type     string `json:"type"`
	LastSeen string `json:"lastSeen"`
}

func (q *Queries) CreateMissingPet(ctx context.Context, arg CreateMissingPetParams) (CreateMissingPetRow, error) {
	row := q.db.QueryRowContext(ctx, createMissingPet,
		arg.Name,
		arg.Type,
		arg.LastSeen,
		arg.OwnerID,
	)
	var i CreateMissingPetRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.LastSeen,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO
pet_owners (name, phone, email, address, hash)
VALUES (?, ?, ?, ?, ?)
RETURNING id, name, phone, email, address
`

type CreateUserParams struct {
	Name    string `json:"name"`
	Phone   string `json:"phone"`
	Email   string `json:"email"`
	Address string `json:"address"`
	Hash    []byte `json:"hash"`
}

type CreateUserRow struct {
	ID      int64  `json:"id"`
	Name    string `json:"name"`
	Phone   string `json:"phone"`
	Email   string `json:"email"`
	Address string `json:"address"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Name,
		arg.Phone,
		arg.Email,
		arg.Address,
		arg.Hash,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Address,
	)
	return i, err
}

const doesUserOwnThePet = `-- name: DoesUserOwnThePet :one
SELECT 1 FROM missing_pets WHERE id = ? AND owner_id = ?
`

type DoesUserOwnThePetParams struct {
	ID      int64 `json:"id"`
	OwnerID int64 `json:"ownerId"`
}

func (q *Queries) DoesUserOwnThePet(ctx context.Context, arg DoesUserOwnThePetParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, doesUserOwnThePet, arg.ID, arg.OwnerID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const findMissingPetsByName = `-- name: FindMissingPetsByName :many
SELECT id, name, type, last_seen FROM
missing_pets
WHERE remove_special_characters(name)
LIKE remove_special_characters(CAST(?1 AS TEXT))
`

type FindMissingPetsByNameRow struct {
	ID       int64  `json:"id"`
	Name     string `json:"name"`
	Type     string `json:"type"`
	LastSeen string `json:"lastSeen"`
}

func (q *Queries) FindMissingPetsByName(ctx context.Context, name string) ([]FindMissingPetsByNameRow, error) {
	rows, err := q.db.QueryContext(ctx, findMissingPetsByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindMissingPetsByNameRow{}
	for rows.Next() {
		var i FindMissingPetsByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.LastSeen,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, name, phone, email, address, hash FROM pet_owners WHERE email = ?
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (PetOwner, error) {
	row := q.db.QueryRowContext(ctx, findUserByEmail, email)
	var i PetOwner
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Address,
		&i.Hash,
	)
	return i, err
}

const findUserById = `-- name: FindUserById :one
SELECT id, name, phone, email, address FROM pet_owners WHERE id = ?
`

type FindUserByIdRow struct {
	ID      int64  `json:"id"`
	Name    string `json:"name"`
	Phone   string `json:"phone"`
	Email   string `json:"email"`
	Address string `json:"address"`
}

func (q *Queries) FindUserById(ctx context.Context, id int64) (FindUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, findUserById, id)
	var i FindUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Address,
	)
	return i, err
}

const getAllPetsNameFilter = `-- name: GetAllPetsNameFilter :many
SELECT missing_pets.id, missing_pets.name, missing_pets.type, missing_pets.last_seen, pet_owners.id as owner_id
FROM missing_pets 
JOIN pet_owners ON missing_pets.owner_id = pet_owners.id
WHERE (missing_pets.name LIKE CAST(?1 AS TEXT))
LIMIT ?3 OFFSET ?2
`

type GetAllPetsNameFilterParams struct {
	Name   string `json:"name"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

type GetAllPetsNameFilterRow struct {
	ID       int64  `json:"id"`
	Name     string `json:"name"`
	Type     string `json:"type"`
	LastSeen string `json:"lastSeen"`
	OwnerID  int64  `json:"ownerId"`
}

func (q *Queries) GetAllPetsNameFilter(ctx context.Context, arg GetAllPetsNameFilterParams) ([]GetAllPetsNameFilterRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllPetsNameFilter, arg.Name, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllPetsNameFilterRow{}
	for rows.Next() {
		var i GetAllPetsNameFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.LastSeen,
			&i.OwnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPetByOwnerAndId = `-- name: GetPetByOwnerAndId :one
SELECT id, name, type, last_seen FROM missing_pets WHERE id = ? AND owner_id = ?
`

type GetPetByOwnerAndIdParams struct {
	ID      int64 `json:"id"`
	OwnerID int64 `json:"ownerId"`
}

type GetPetByOwnerAndIdRow struct {
	ID       int64  `json:"id"`
	Name     string `json:"name"`
	Type     string `json:"type"`
	LastSeen string `json:"lastSeen"`
}

func (q *Queries) GetPetByOwnerAndId(ctx context.Context, arg GetPetByOwnerAndIdParams) (GetPetByOwnerAndIdRow, error) {
	row := q.db.QueryRowContext(ctx, getPetByOwnerAndId, arg.ID, arg.OwnerID)
	var i GetPetByOwnerAndIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.LastSeen,
	)
	return i, err
}

const getUserPets = `-- name: GetUserPets :many
SELECT id, name, type, last_seen FROM missing_pets WHERE owner_id = ?
`

type GetUserPetsRow struct {
	ID       int64  `json:"id"`
	Name     string `json:"name"`
	Type     string `json:"type"`
	LastSeen string `json:"lastSeen"`
}

func (q *Queries) GetUserPets(ctx context.Context, ownerID int64) ([]GetUserPetsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserPets, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPetsRow{}
	for rows.Next() {
		var i GetUserPetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.LastSeen,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserPet = `-- name: RemoveUserPet :exec
DELETE FROM missing_pets WHERE id = ? AND owner_id = ?
`

type RemoveUserPetParams struct {
	ID      int64 `json:"id"`
	OwnerID int64 `json:"ownerId"`
}

func (q *Queries) RemoveUserPet(ctx context.Context, arg RemoveUserPetParams) error {
	_, err := q.db.ExecContext(ctx, removeUserPet, arg.ID, arg.OwnerID)
	return err
}

const uploadPhoto = `-- name: UploadPhoto :one
INSERT INTO
missing_pet_photos (pet_id, encoded_data)
VALUES (?, ?)
RETURNING id
`

type UploadPhotoParams struct {
	PetID       int64  `json:"petId"`
	EncodedData string `json:"encodedData"`
}

func (q *Queries) UploadPhoto(ctx context.Context, arg UploadPhotoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, uploadPhoto, arg.PetID, arg.EncodedData)
	var id int64
	err := row.Scan(&id)
	return id, err
}
